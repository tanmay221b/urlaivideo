import http from "http";
import path from "path";
import child_process from "child_process";
import { fileURLToPath } from "url";
import { gunzipSync } from "zlib";
function globalOptsToEnv(env, opts) {
    if (!opts) {
        return;
    }
    if (opts.APIKey) {
        env["OPENAI_API_KEY"] = opts.APIKey;
    }
    if (opts.BaseURL) {
        env["OPENAI_BASE_URL"] = opts.BaseURL;
    }
    if (opts.DefaultModel) {
        env["GPTSCRIPT_SDKSERVER_DEFAULT_MODEL"] = opts.DefaultModel;
    }
    if (opts.DefaultModelProvider) {
        env["GPTSCRIPT_SDKSERVER_DEFAULT_MODEL_PROVIDER"] = opts.DefaultModelProvider;
    }
}
export var RunEventType;
(function (RunEventType) {
    RunEventType["Event"] = "event";
    RunEventType["RunStart"] = "runStart";
    RunEventType["RunFinish"] = "runFinish";
    RunEventType["CallStart"] = "callStart";
    RunEventType["CallChat"] = "callChat";
    RunEventType["CallSubCalls"] = "callSubCalls";
    RunEventType["CallProgress"] = "callProgress";
    RunEventType["CallConfirm"] = "callConfirm";
    RunEventType["CallContinue"] = "callContinue";
    RunEventType["CallFinish"] = "callFinish";
    RunEventType["Prompt"] = "prompt";
})(RunEventType || (RunEventType = {}));
export class GPTScript {
    static serverURL = "";
    static serverProcess;
    static instanceCount = 0;
    opts;
    constructor(opts) {
        this.opts = opts || {};
        GPTScript.instanceCount++;
        let startSDK = !GPTScript.serverProcess && !GPTScript.serverURL && !this.opts.URL;
        if (!GPTScript.serverURL) {
            GPTScript.serverURL = process.env.GPTSCRIPT_URL ?? "";
            startSDK = startSDK && !GPTScript.serverURL;
        }
        if (!this.opts.Token) {
            this.opts.Token = process.env.GPTSCRIPT_TOKEN;
        }
        if (startSDK) {
            let env = process.env;
            if (this.opts.Env) {
                env = {
                    "NODE_ENV": process.env.NODE_ENV
                };
                for (const v of this.opts.Env) {
                    const equalIndex = v.indexOf("=");
                    if (equalIndex === -1) {
                        env[v] = "";
                    }
                    else {
                        env[v.substring(0, equalIndex)] = v.substring(equalIndex + 1);
                    }
                }
            }
            globalOptsToEnv(env, this.opts);
            process.on("exit", (code) => {
                if (GPTScript.serverProcess) {
                    GPTScript.serverProcess.stdin?.end();
                    GPTScript.serverProcess.kill(code);
                }
            });
            GPTScript.serverProcess = child_process.spawn(getCmdPath(), ["sys.sdkserver", "--listen-address", "127.0.0.1:0"], {
                env: env,
                stdio: ["pipe", "ignore", "pipe"]
            });
            GPTScript.serverProcess.stderr?.on("data", (data) => {
                let url = data.toString().trim();
                if (url.includes("=")) {
                    url = url.substring(url.indexOf("=") + 1);
                }
                GPTScript.serverURL = `http://${url}`;
                GPTScript.serverProcess.stderr?.removeAllListeners();
            });
        }
        else {
            if (!this.opts.URL) {
                this.opts.URL = GPTScript.serverURL;
            }
            if (!this.opts.Env) {
                this.opts.Env = [];
            }
            if (this.opts.URL) {
                this.opts.Env.push(`GPTSCRIPT_URL=${this.opts.URL}`);
            }
            if (this.opts.Token) {
                this.opts.Env.push(`GPTSCRIPT_TOKEN=${this.opts.Token}`);
            }
        }
    }
    close() {
        GPTScript.instanceCount--;
        if (GPTScript.instanceCount === 0 && GPTScript.serverProcess) {
            GPTScript.serverURL = process.env.GPTSCRIPT_URL ?? "";
            GPTScript.serverProcess.kill("SIGTERM");
            GPTScript.serverProcess.stdin?.end();
        }
    }
    listModels(providers, credentialOverrides) {
        if (this.opts.DefaultModelProvider) {
            if (!providers) {
                providers = [];
            }
            providers.push(this.opts.DefaultModelProvider);
        }
        return this.runBasicCommand("list-models", {
            "providers": providers,
            "env": this.opts.Env,
            "credentialOverrides": credentialOverrides
        });
    }
    version() {
        return this.runBasicCommand("version");
    }
    async runBasicCommand(cmd, body) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand(cmd, "", { URL: this.opts.URL, Token: this.opts.Token });
        r.requestNoStream(body);
        return r.text();
    }
    /**
     * Runs a tool with the specified name and options.
     *
     * @param {string} toolName - The name of the tool to run. Can be a file path, URL, or GitHub URL.
     * @param {RunOpts} [opts={}] - The options for running the tool.
     * @return {Run} The Run object representing the running tool.
     */
    async run(toolName, opts = {}) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        if (this.opts.Env) {
            opts.env = this.opts.Env.concat(opts.env || []);
        }
        return (new Run("run", toolName, { ...this.opts, ...opts })).nextChat(opts.input);
    }
    /**
     * Evaluates the given tool and returns a Run object.
     *
     * @param {ToolDef | ToolDef[]} tool - The tool to be evaluated. Can be a single ToolDef object or an array of ToolDef objects.
     * @param {RunOpts} [opts={}] - Optional options for the evaluation.
     * @return {Run} The Run object representing the evaluation.
     */
    async evaluate(tool, opts = {}) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        if (this.opts.Env) {
            opts.env = this.opts.Env.concat(opts.env || []);
        }
        return (new Run("evaluate", tool, { ...this.opts, ...opts })).nextChat(opts.input);
    }
    async parse(fileName, disableCache) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("parse", fileName, {
            disableCache: disableCache,
            URL: this.opts.URL,
            Token: this.opts.Token
        });
        r.request({ file: fileName });
        return parseBlocksFromNodes((await r.json()).nodes);
    }
    async parseContent(toolContent) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("parse", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ content: toolContent });
        return parseBlocksFromNodes((await r.json()).nodes);
    }
    async stringify(blocks) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const nodes = [];
        for (const block of blocks) {
            if (block.type === "text") {
                nodes.push({
                    textNode: {
                        text: "!" + (block.format || "text") + "\n" + block.content
                    }
                });
            }
            else {
                nodes.push({
                    toolNode: {
                        tool: block
                    }
                });
            }
        }
        const r = new RunSubcommand("fmt", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ nodes: nodes });
        return r.text();
    }
    async confirm(response) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const resp = await fetch(`${this.opts.URL}/confirm/${response.id}`, {
            method: "POST",
            body: JSON.stringify(response)
        });
        if (resp.status < 200 || resp.status >= 400) {
            throw new Error(`Failed to confirm ${response.id}: ${await resp.text()}`);
        }
    }
    async promptResponse(response) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const resp = await fetch(`${this.opts.URL}/prompt-response/${response.id}`, {
            method: "POST",
            body: JSON.stringify(response.responses)
        });
        if (resp.status < 200 || resp.status >= 400) {
            throw new Error(`Failed to respond to prompt ${response.id}: ${await resp.text()}`);
        }
    }
    /**
     * Loads a file into a Program.
     *
     * @param {string} fileName - The name of the file to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    async load(fileName, disableCache, subTool) {
        return this._load({ file: fileName, disableCache, subTool });
    }
    /**
     * Loads content into a Program.
     *
     * @param {string} content - The content to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    async loadContent(content, disableCache, subTool) {
        return this._load({ content, disableCache, subTool });
    }
    /**
     * Loads tools into a Program.
     *
     * @param {ToolDef[]} toolDefs - The tools to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    async loadTools(toolDefs, disableCache, subTool) {
        return this._load({ toolDefs, disableCache, subTool });
    }
    async listCredentials(context, allContexts) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("credentials", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ context, allContexts });
        const out = await r.json();
        return out.map((c) => jsonToCredential(JSON.stringify(c)));
    }
    async createCredential(credential) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("credentials/create", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ content: credentialToJSON(credential) });
        await r.text();
    }
    async revealCredential(context, name) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("credentials/reveal", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ context, name });
        return jsonToCredential(await r.text());
    }
    async deleteCredential(context, name) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("credentials/delete", "", { URL: this.opts.URL, Token: this.opts.Token });
        r.request({ context: [context], name });
        await r.text();
    }
    /**
     * Helper method to handle the common logic for loading.
     *
     * @param {any} payload - The payload to send in the request.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    async _load(payload) {
        if (!this.opts.URL) {
            await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("load", payload.toolDefs || [], { URL: this.opts.URL, Token: this.opts.Token });
        r.request(payload);
        return (await r.json());
    }
    async testGPTScriptURL(count) {
        while (count > 0) {
            try {
                await fetch(`${GPTScript.serverURL}/healthz`);
                this.opts.URL = GPTScript.serverURL;
                if (!this.opts.Env) {
                    this.opts.Env = [];
                }
                this.opts.Env.push(`GPTSCRIPT_URL=${this.opts.URL}`);
                if (this.opts.Token) {
                    this.opts.Env.push(`GPTSCRIPT_TOKEN=${this.opts.Token}`);
                }
                return;
            }
            catch {
                if (count === 0) {
                }
                await new Promise(r => setTimeout(r, 500));
                count--;
            }
        }
        throw new Error("Failed to wait for gptscript to be ready");
    }
}
export class Run {
    id;
    opts;
    tools;
    state = RunState.Creating;
    calls = {};
    err = "";
    stdout;
    requestPath = "";
    promise;
    req;
    stderr;
    callbacks = {};
    chatState;
    parentCallId = "";
    prg;
    respondingToolId;
    constructor(subCommand, tools, opts) {
        this.id = randomId("run-");
        this.requestPath = subCommand;
        this.opts = opts;
        this.tools = tools;
    }
    nextChat(input = "") {
        if (this.state !== RunState.Continue && this.state !== RunState.Creating && this.state !== RunState.Error) {
            throw (new Error(`Run must in creating, continue or error state, not ${this.state}`));
        }
        let run = this;
        if (run.state !== RunState.Creating) {
            run = new this.constructor(this.requestPath, this.tools, this.opts);
        }
        if (this.chatState && this.state === RunState.Continue) {
            // Only update the chat state if the previous run didn't error.
            // The chat state on opts will be the chat state for the last successful run.
            this.opts.chatState = this.chatState;
        }
        run.opts.input = input;
        if (Array.isArray(this.tools)) {
            run.request({ toolDefs: this.tools, ...this.opts });
        }
        else if (typeof this.tools === "string") {
            run.request({ file: this.tools, ...this.opts });
        }
        else {
            // In this last case, this.tools is a single ToolDef.
            run.request({ toolDefs: [this.tools], ...this.opts });
        }
        return run;
    }
    processStdout(data) {
        if (typeof data === "string") {
            if (data.trim() === "") {
                return "";
            }
            try {
                data = JSON.parse(data);
            }
            catch (e) {
                return data;
            }
        }
        const out = data;
        if (out.done === undefined || !out.done) {
            this.chatState = JSON.stringify(out.state);
            this.state = RunState.Continue;
            this.respondingToolId = out.toolID;
        }
        else {
            this.state = RunState.Finished;
            this.chatState = undefined;
        }
        return "";
    }
    request(tool) {
        if (!this.opts.URL) {
            throw new Error("request() requires URL to be set");
        }
        const options = this.requestOptions(this.opts.URL, this.opts.Token || "", this.requestPath, tool);
        options.headers = { "Transfer-Encoding": "chunked", ...options.headers };
        this.promise = new Promise(async (resolve, reject) => {
            let frag = "";
            this.req = http.request(options, (res) => {
                this.state = RunState.Running;
                res.on("data", (chunk) => {
                    for (let line of (frag + chunk.toString()).split("\n")) {
                        const c = line.replace(/^(data: )/, "").trim();
                        if (!c) {
                            continue;
                        }
                        if (c === "[DONE]") {
                            return;
                        }
                        let e;
                        try {
                            e = JSON.parse(c);
                        }
                        catch {
                            frag = c;
                            return;
                        }
                        if (e.stderr) {
                            this.stderr = (this.stderr || "") + (typeof e.stderr === "string" ? e.stderr : JSON.stringify(e.stderr));
                            frag = "";
                        }
                        else if (e.stdout) {
                            frag = this.processStdout(e.stdout);
                        }
                        else {
                            frag = this.emitEvent(c);
                        }
                    }
                });
                res.on("end", () => {
                    if (this.state === RunState.Running || this.state === RunState.Finished || this.state === RunState.Continue) {
                        if (this.stdout || !this.stderr) {
                            if (this.state !== RunState.Continue) {
                                this.state = RunState.Finished;
                            }
                            resolve(this.stdout || "");
                        }
                        else {
                            this.state = RunState.Error;
                            reject(new Error(this.stderr));
                        }
                    }
                    else if (this.state === RunState.Error) {
                        reject(new Error(this.err));
                    }
                });
                res.on("aborted", () => {
                    if (this.state !== RunState.Finished && this.state !== RunState.Error) {
                        this.state = RunState.Error;
                        this.err = "Run has been aborted";
                        reject(new Error(this.err));
                    }
                });
                res.on("error", (error) => {
                    if (this.state !== RunState.Error) {
                        this.state = RunState.Error;
                        this.err = error.message || "";
                    }
                    reject(new Error(this.err));
                });
            });
            this.req.on("error", (error) => {
                if (this.state !== RunState.Error) {
                    this.state = RunState.Error;
                    this.err = error.message || "";
                }
                reject(new Error(this.err));
            });
            this.req.write(JSON.stringify({ ...tool, ...this.opts }));
            this.req.end();
        });
    }
    requestNoStream(tool) {
        if (!this.opts.URL) {
            throw new Error("request() requires gptscriptURL to be set");
        }
        const options = this.requestOptions(this.opts.URL, this.opts.Token || "", this.requestPath, tool);
        if (tool) {
            options.body = JSON.stringify({ ...tool, ...this.opts });
        }
        const req = new Request(this.opts.URL + "/" + this.requestPath, options);
        this.promise = new Promise(async (resolve, reject) => {
            fetch(req).then(resp => {
                return resp.json();
            }).then(res => {
                resolve(res.stdout);
            }).catch(e => {
                reject(new Error(e));
            });
        });
    }
    requestOptions(gptscriptURL, token, path, tool) {
        let method = "GET";
        if (tool) {
            method = "POST";
        }
        const url = new URL(gptscriptURL);
        const headers = {
            "Content-Type": "application/json"
        };
        if (token) {
            headers["Authorization"] = `Bearer ${token}`;
        }
        return {
            hostname: url.hostname,
            port: url.port || 80,
            protocol: url.protocol || "http:",
            path: "/" + path,
            method: method,
            headers: headers
        };
    }
    on(event, listener) {
        if (!this.callbacks[event]) {
            this.callbacks[event] = [];
        }
        this.callbacks[event].push(listener);
        return this;
    }
    text() {
        if (this.err) {
            throw new Error(this.err);
        }
        if (!this.promise) {
            throw new Error("Run not started");
        }
        return this.promise;
    }
    async json() {
        return JSON.parse(await this.text());
    }
    currentChatState() {
        return this.chatState;
    }
    parentCallFrame() {
        if (this.parentCallId) {
            return this.calls[this.parentCallId];
        }
        return undefined;
    }
    program() {
        return this.prg;
    }
    respondingTool() {
        return this.respondingToolId ? this.prg?.toolSet[this.respondingToolId] : undefined;
    }
    close() {
        if (this.req) {
            this.req.destroy();
            return;
        }
        throw new Error("Run not started");
    }
    emitEvent(data) {
        for (let event of data.split("\n")) {
            event = event.trim();
            if (!event) {
                continue;
            }
            let f;
            try {
                const obj = JSON.parse(event);
                if (obj.run) {
                    f = obj.run;
                }
                else if (obj.call) {
                    f = obj.call;
                }
                else if (obj.prompt) {
                    f = obj.prompt;
                }
                else {
                    return event;
                }
            }
            catch (error) {
                return event;
            }
            if (!this.state) {
                this.state = RunState.Creating;
            }
            if (f.type === RunEventType.Prompt && !this.opts.prompt) {
                this.state = RunState.Error;
                this.err = `prompt occurred when prompt was not allowed: Message: ${f.message}\nFields: ${f.fields}\nSensitive: ${f.sensitive}`;
                this.close();
                return "";
            }
            if (f.type === RunEventType.RunStart) {
                this.state = RunState.Running;
                this.prg = f.program;
            }
            else if (f.type === RunEventType.RunFinish) {
                if (f.error) {
                    this.state = RunState.Error;
                    this.err = f.error || "";
                }
                else {
                    this.state = RunState.Finished;
                    this.stdout = f.output || "";
                }
            }
            else if (f.type.startsWith("call")) {
                f = f;
                if (!f.parentID && this.parentCallId === "") {
                    this.parentCallId = f.id;
                }
                this.calls[f.id] = f;
            }
            this.emit(RunEventType.Event, f);
            this.emit(f.type, f);
        }
        return "";
    }
    emit(event, data) {
        for (const cb of this.callbacks[event] || []) {
            cb(data);
        }
    }
}
class RunSubcommand extends Run {
    constructor(subCommand, tool, opts) {
        super(subCommand, tool, opts);
    }
    processStdout(data) {
        if (typeof data === "string") {
            this.stdout = (this.stdout || "") + data;
        }
        else {
            this.stdout = JSON.stringify(data);
        }
        return "";
    }
}
export const ArgumentSchemaType = "object";
export const PropertyType = "string";
export const TextType = "text";
export var RunState;
(function (RunState) {
    RunState["Creating"] = "creating";
    RunState["Running"] = "running";
    RunState["Continue"] = "continue";
    RunState["Finished"] = "finished";
    RunState["Error"] = "error";
})(RunState || (RunState = {}));
export var ToolCategory;
(function (ToolCategory) {
    ToolCategory["ProviderToolCategory"] = "provider";
    ToolCategory["CredentialToolCategory"] = "credential";
    ToolCategory["ContextToolCategory"] = "context";
    ToolCategory["InputToolCategory"] = "input";
    ToolCategory["OutputToolCategory"] = "output";
    ToolCategory["NoCategory"] = "";
})(ToolCategory || (ToolCategory = {}));
export function getEnv(key, def = "") {
    let v = process.env[key] || "";
    if (v == "") {
        return def;
    }
    if (v.startsWith("{\"_gz\":\"") && v.endsWith("\"}")) {
        try {
            return gunzipSync(Buffer.from(v.slice(8, -2), "base64")).toString("utf8");
        }
        catch (e) {
        }
    }
    return v;
}
function getCmdPath() {
    if (process.env.GPTSCRIPT_BIN) {
        return process.env.GPTSCRIPT_BIN;
    }
    return path.join(path.dirname(fileURLToPath(import.meta.url)), "..", "bin", "gptscript" + (process.platform === "win32" ? ".exe" : ""));
}
function parseBlocksFromNodes(nodes) {
    const blocks = [];
    if (!nodes) {
        return blocks;
    }
    for (const node of nodes) {
        if (node.toolNode) {
            if (!node.toolNode.tool.id) {
                node.toolNode.tool.id = randomId("tool-");
            }
            blocks.push({
                type: node.toolNode.tool.type || "tool",
                ...node.toolNode.tool,
            });
        }
        if (node.textNode) {
            const format = node.textNode.text.substring(1, node.textNode.text.indexOf("\n")).trim() || "text";
            blocks.push({
                id: randomId("text-"),
                type: "text",
                format: format,
                content: node.textNode.text.substring(node.textNode.text.indexOf("\n") + 1).trim(),
            });
        }
    }
    return blocks;
}
function randomId(prefix) {
    return prefix + Math.random().toString(36).substring(2, 12);
}
export var CredentialType;
(function (CredentialType) {
    CredentialType["Tool"] = "tool";
    CredentialType["ModelProvider"] = "modelProvider";
})(CredentialType || (CredentialType = {}));
export function credentialToJSON(c) {
    const expiresAt = c.expiresAt ? c.expiresAt.toISOString() : undefined;
    const type = c.type === CredentialType.Tool ? "tool" : "modelProvider";
    return JSON.stringify({
        context: c.context,
        toolName: c.name,
        type: type,
        env: c.env,
        ephemeral: c.ephemeral,
        expiresAt: expiresAt,
        refreshToken: c.refreshToken
    });
}
function jsonToCredential(cred) {
    const c = JSON.parse(cred);
    return {
        context: c.context,
        name: c.toolName,
        type: c.type === "tool" ? CredentialType.Tool : CredentialType.ModelProvider,
        env: c.env,
        ephemeral: c.ephemeral,
        expiresAt: c.expiresAt ? new Date(c.expiresAt) : undefined,
        refreshToken: c.refreshToken
    };
}
//# sourceMappingURL=gptscript.js.map