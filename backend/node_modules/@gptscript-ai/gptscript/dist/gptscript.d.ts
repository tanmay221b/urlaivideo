export interface GlobalOpts {
    URL?: string;
    Token?: string;
    CacheDir?: string;
    APIKey?: string;
    BaseURL?: string;
    DefaultModel?: string;
    DefaultModelProvider?: string;
    Env?: string[];
}
export interface RunOpts {
    input?: string;
    disableCache?: boolean;
    quiet?: boolean;
    chdir?: string;
    subTool?: string;
    workspace?: string;
    chatState?: string;
    confirm?: boolean;
    prompt?: boolean;
    credentialOverrides?: string[];
    credentialContexts?: string[];
    location?: string;
    env?: string[];
    forceSequential?: boolean;
    URL?: string;
    Token?: string;
    CacheDir?: string;
    APIKey?: string;
    BaseURL?: string;
    DefaultModel?: string;
}
export declare enum RunEventType {
    Event = "event",
    RunStart = "runStart",
    RunFinish = "runFinish",
    CallStart = "callStart",
    CallChat = "callChat",
    CallSubCalls = "callSubCalls",
    CallProgress = "callProgress",
    CallConfirm = "callConfirm",
    CallContinue = "callContinue",
    CallFinish = "callFinish",
    Prompt = "prompt"
}
export declare class GPTScript {
    private static serverURL;
    private static serverProcess;
    private static instanceCount;
    private readonly opts;
    constructor(opts?: GlobalOpts);
    close(): void;
    listModels(providers?: string[], credentialOverrides?: string[]): Promise<string>;
    version(): Promise<string>;
    runBasicCommand(cmd: string, body?: any): Promise<string>;
    /**
     * Runs a tool with the specified name and options.
     *
     * @param {string} toolName - The name of the tool to run. Can be a file path, URL, or GitHub URL.
     * @param {RunOpts} [opts={}] - The options for running the tool.
     * @return {Run} The Run object representing the running tool.
     */
    run(toolName: string, opts?: RunOpts): Promise<Run>;
    /**
     * Evaluates the given tool and returns a Run object.
     *
     * @param {ToolDef | ToolDef[]} tool - The tool to be evaluated. Can be a single ToolDef object or an array of ToolDef objects.
     * @param {RunOpts} [opts={}] - Optional options for the evaluation.
     * @return {Run} The Run object representing the evaluation.
     */
    evaluate(tool: Tool | ToolDef | ToolDef[], opts?: RunOpts): Promise<Run>;
    parse(fileName: string, disableCache?: boolean): Promise<Block[]>;
    parseContent(toolContent: string): Promise<Block[]>;
    stringify(blocks: Block[]): Promise<string>;
    confirm(response: AuthResponse): Promise<void>;
    promptResponse(response: PromptResponse): Promise<void>;
    /**
     * Loads a file into a Program.
     *
     * @param {string} fileName - The name of the file to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    load(fileName: string, disableCache?: boolean, subTool?: string): Promise<LoadResponse>;
    /**
     * Loads content into a Program.
     *
     * @param {string} content - The content to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    loadContent(content: string, disableCache?: boolean, subTool?: string): Promise<LoadResponse>;
    /**
     * Loads tools into a Program.
     *
     * @param {ToolDef[]} toolDefs - The tools to load.
     * @param {boolean} [disableCache] - Whether to disable the cache.
     * @param {string} [subTool] - The sub-tool to use.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    loadTools(toolDefs: ToolDef[], disableCache?: boolean, subTool?: string): Promise<LoadResponse>;
    listCredentials(context: Array<string>, allContexts: boolean): Promise<Array<Credential>>;
    createCredential(credential: Credential): Promise<void>;
    revealCredential(context: Array<string>, name: string): Promise<Credential>;
    deleteCredential(context: string, name: string): Promise<void>;
    /**
     * Helper method to handle the common logic for loading.
     *
     * @param {any} payload - The payload to send in the request.
     * @return {Promise<LoadResponse>} The loaded program.
     */
    private _load;
    private testGPTScriptURL;
}
export declare class Run {
    readonly id: string;
    readonly opts: RunOpts;
    readonly tools?: ToolDef | ToolDef[] | string;
    state: RunState;
    calls: Record<string, CallFrame>;
    err: string;
    protected stdout?: string;
    private readonly requestPath;
    private promise?;
    private req?;
    private stderr?;
    private callbacks;
    private chatState?;
    private parentCallId;
    private prg?;
    private respondingToolId?;
    constructor(subCommand: string, tools: ToolDef | ToolDef[] | string, opts: RunOpts);
    nextChat(input?: string): Run;
    processStdout(data: string | object): string;
    request(tool: any): void;
    requestNoStream(tool: any): void;
    requestOptions(gptscriptURL: string, token: string, path: string, tool: any): {
        hostname: string;
        port: string | number;
        protocol: string;
        path: string;
        method: string;
        headers: any;
    };
    on(event: RunEventType.RunStart | RunEventType.RunFinish, listener: (data: RunFrame) => void): this;
    on(event: RunEventType.CallStart | RunEventType.CallProgress | RunEventType.CallContinue | RunEventType.CallChat | RunEventType.CallConfirm | RunEventType.CallFinish, listener: (data: CallFrame) => void): this;
    on(event: RunEventType.Prompt, listener: (data: PromptFrame) => void): this;
    on(event: RunEventType.Event, listener: (data: Frame) => void): this;
    text(): Promise<string>;
    json(): Promise<any>;
    currentChatState(): string | undefined;
    parentCallFrame(): CallFrame | undefined;
    program(): Program | undefined;
    respondingTool(): Tool | undefined;
    close(): void;
    private emitEvent;
    private emit;
}
export type Arguments = string | Record<string, string>;
export declare const ArgumentSchemaType: "object";
export interface ArgumentSchema {
    type: typeof ArgumentSchemaType;
    properties?: Record<string, Property>;
    required?: string[];
}
export interface Program {
    name: string;
    entryToolId: string;
    toolSet: Record<string, Tool>;
    openAPICache: Record<string, any>;
}
export declare const PropertyType: "string";
export interface Property {
    type: typeof PropertyType;
    description: string;
    default?: string;
}
export interface Repo {
    VCS: string;
    Root: string;
    Path: string;
    Name: string;
    Revision: string;
}
export type ToolType = "tool" | "context" | "credential" | "input" | "output" | "agent" | "assistant" | "provider" | "";
export interface ToolDef {
    name?: string;
    description?: string;
    maxTokens?: number;
    modelName?: string;
    modelProvider?: boolean;
    jsonResponse?: boolean;
    temperature?: number;
    cache?: boolean;
    chat?: boolean;
    internalPrompt?: boolean;
    arguments?: ArgumentSchema;
    tools?: string[];
    globalTools?: string[];
    globalModelName?: string;
    context?: string[];
    exportContext?: string[];
    export?: string[];
    agents?: string[];
    credentials?: string[];
    exportCredentials?: string[];
    inputFilters?: string[];
    exportInputFilters?: string[];
    outputFilters?: string[];
    exportOutputFilters?: string[];
    instructions?: string;
    type?: ToolType;
    metaData?: Record<string, string>;
}
export interface ToolReference {
    named: string;
    reference: string;
    arg: string;
    toolID: string;
}
export interface Tool extends ToolDef {
    id: string;
    toolMapping?: Record<string, ToolReference[]>;
    localTools?: Record<string, string>;
    source?: SourceRef;
    workingDir?: string;
}
export interface SourceRef {
    location: string;
    lineNo: number;
    repo?: Repo;
}
export declare const TextType: "text";
export interface Text {
    id: string;
    type: typeof TextType;
    format: string;
    content: string;
}
export type Block = Tool | Text;
export declare enum RunState {
    Creating = "creating",
    Running = "running",
    Continue = "continue",
    Finished = "finished",
    Error = "error"
}
export declare enum ToolCategory {
    ProviderToolCategory = "provider",
    CredentialToolCategory = "credential",
    ContextToolCategory = "context",
    InputToolCategory = "input",
    OutputToolCategory = "output",
    NoCategory = ""
}
export interface RunFrame {
    id: string;
    type: RunEventType.RunStart | RunEventType.RunFinish;
    program: Program;
    input: string;
    output: string;
    error: string;
    start: string;
    end: string;
    state: RunState;
    chatState: any;
}
export interface Call {
    toolID: string;
    input?: string;
}
export interface Output {
    content?: string;
    subCalls: Record<string, Call>;
}
export interface InputContext {
    toolID: string;
    content: string;
}
export interface Usage {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
}
export interface CallFrame {
    id: string;
    tool?: Tool;
    agentGroup?: ToolReference[];
    currentAgent?: ToolReference;
    displayText?: string;
    inputContext: InputContext[];
    toolCategory?: ToolCategory;
    toolName: string;
    parentID?: string;
    type: RunEventType.CallStart | RunEventType.CallChat | RunEventType.CallConfirm | RunEventType.CallContinue | RunEventType.CallSubCalls | RunEventType.CallProgress | RunEventType.CallFinish;
    start: string;
    end: string;
    input: Arguments;
    output: Output[];
    error?: string;
    usage: Usage;
    chatResponseCached: boolean;
    toolResults: number;
    llmRequest?: any;
    llmResponse?: any;
}
export interface PromptFrame {
    id: string;
    type: RunEventType.Prompt;
    time: string;
    message: string;
    fields: string[];
    sensitive: boolean;
    metadata: Record<string, string>;
}
export type Frame = RunFrame | CallFrame | PromptFrame;
export interface AuthResponse {
    id: string;
    accept: boolean;
    message?: string;
}
export interface PromptResponse {
    id: string;
    responses: Record<string, string>;
}
export interface LoadResponse {
    program: Program;
}
export declare function getEnv(key: string, def?: string): string;
export declare enum CredentialType {
    Tool = "tool",
    ModelProvider = "modelProvider"
}
export type Credential = {
    context: string;
    name: string;
    type: CredentialType;
    env: Record<string, string>;
    ephemeral: boolean;
    expiresAt?: Date | undefined;
    refreshToken?: string | undefined;
};
export declare function credentialToJSON(c: Credential): string;
